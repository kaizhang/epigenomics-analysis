{
  "hash": "8999c0e51ea14f2d9fc01f321769d77c",
  "result": {
    "markdown": "---\nexecute:\n  freeze: auto\n---\n\nAnnData -- Annotated Data\n=========================\n\n## Introduction\n\nAnnData is both a data structure and an on-disk file specification that facilitates the sharing of labeled data matrices.\n\nThe Python [anndata](https://anndata.readthedocs.io/en/latest/) package supports both in-memory and on-disk representation of AnnData object.\nFor detailed descriptions about the AnnData format, please read `anndata`'s\n[documentation](https://anndata.readthedocs.io/en/latest/).\n\nDespite being an excellent package, the `anndata` package falls short of its support for the on-disk representation or backed mode of AnnData object.\nWhen opened in the backed mode, the in-memory snapshot and on-disk data of AnnData are not in sync with each other, causing inconsistent and unexpected behaviors. \nFor example in the backed mode, `anndata` only supports updates to the `X` slot in the AnnData object, which means any changes to other slots like `obs` will not be written to disk.\nThis make the backed mode very cumbersome to use and often lead to unexpected outcomes.\nAlso, as it still reads all other componenets except `X` into memory, it uses\na lot of memory for large datasets.\n\nTo address these limitations, SnapATAC2 implements its own **out-of-core** AnnData object with\nthe following key features:\n\n- AnnData is fully backed by the underlying hdf5 file. Any operations on the AnnData object\n  will be reflected on the hdf5 file.\n- All elements are lazily loaded. No matter how large is the file, opening it\n  consume almost zero memory. Matrix data can be accessed and processed by chunks,\n  which keeps the memory usage to the minimum.\n- In-memory cache can be turned on to speed up the repetitive access of elements.\n- Featuring an AnnDataSet object to lazily concatenate multiple AnnData objects.\n\n## A tutorial on using backed AnnData objects\n\nIn this section, we will learn the basics about SnapATAC2's AnnData implementation.\n\n### Reading/opening a h5ad file.\n\nSnapATAC2 can open `h5ad` files in either in-memory mode or backed mode.\nBy default, `snapatac2.read` open a `h5ad` file in backed mode.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport snapatac2 as snap\nadata = snap.read(snap.datasets.pbmc5k(type='h5ad'))\nadata\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nAnnData object with n_obs x n_vars = 4363 x 6176550 backed at '/home/kaizhang/.cache/snapatac2/atac_pbmc_5k.h5ad'\n    obs: 'tsse', 'n_fragment', 'frac_dup', 'frac_mito', 'doublet_score', 'is_doublet', 'leiden'\n    var: 'selected'\n    uns: 'scrublet_threshold', 'reference_sequences', 'scrublet_sim_doublet_score', 'spectral_eigenvalue'\n    obsm: 'X_umap', 'X_spectral', 'insertion'\n    obsp: 'distances'\n```\n:::\n:::\n\n\nYou can turn the backed mode off using `backed=False`, which will use the Python \n`anndata` package to read the file and create an in-memory AnnData object.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport snapatac2 as snap\nadata = snap.read(snap.datasets.pbmc5k(type='h5ad'), backed=None)\nadata\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nUpdating file 'atac_pbmc_5k.h5ad' from 'https://data.mendeley.com/api/datasets/dr2z4jbcx3/draft/files/d90adfd1-b4b8-4dcd-8704-9ab19f104116?a=758c37e5-4832-4c91-af89-9a1a83a051b3' to '/home/kaizhang/.cache/snapatac2'.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nAnnData object with n_obs × n_vars = 4363 × 6176550\n    obs: 'tsse', 'n_fragment', 'frac_dup', 'frac_mito', 'doublet_score', 'is_doublet', 'leiden'\n    var: 'selected'\n    uns: 'reference_sequences', 'scrublet_sim_doublet_score', 'scrublet_threshold', 'spectral_eigenvalue'\n    obsm: 'X_spectral', 'X_umap', 'insertion'\n    obsp: 'distances'\n```\n:::\n:::\n\n\n### Closing a backed AnnData object\n\nThe backed AnnData object in SnapATAC2 does not need to be saved as it is always in\nsync with the data on disk.\nHowever, if you have opened the `h5ad` file in write mode, it is important to remember\nto close the file using the `AnnData.close` method.\nOtherwise, the underlying hdf5 file might be corrupted.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nadata = snap.read(snap.datasets.pbmc5k(type='h5ad'))\nadata.close()\nadata\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nClosed AnnData object\n```\n:::\n:::\n\n\n### Creating a backed AnnData object\n\nYou can use the `AnnData` constructor to create a new AnnData object.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nadata = snap.AnnData(filename='adata.h5ad')\nadata\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nAnnData object with n_obs x n_vars = 0 x 0 backed at 'adata.h5ad'\n```\n:::\n:::\n\n\nYou can then modify slots in the AnnData object.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\nadata.X = np.ones((3, 4))\nadata.obs_names = [\"1\", \"2\", \"3\"]\nadata.var_names = [\"a\", \"b\", \"c\", \"d\"]\nadata.obsm['matrix'] = np.ones((3, 10))\nadata.varm['another_matrix'] = np.ones((4, 10))\nadata\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nAnnData object with n_obs x n_vars = 3 x 4 backed at 'adata.h5ad'\n    obsm: 'matrix'\n    varm: 'another_matrix'\n```\n:::\n:::\n\n\nThe matrices are now saved on the backing hdf5 file and will be cleared from the memory.\n\n### Accessing elements in a backed AnnData object\n\nSlots in backed AnnData object, *e.g.,* `AnnData.X`, `AnnData.obs`, store references to the actual data.\nAccessing those slots does not automatically perform dereferencing or load the data into memory. Instead, a lazy element will be returned, as demonstrated in the example below:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nadata.X\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nArray(f64) element, cache_enabled: no, cached: no\n```\n:::\n:::\n\n\nHowever, asscessing the slots by keys will automatically read the data:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nadata.obsm['matrix']\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],\n       [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]])\n```\n:::\n:::\n\n\nTo retreive the lazy element from `obsm`, you can use:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nadata.obsm.el('matrix')\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nArray(f64) element, cache_enabled: no, cached: no\n```\n:::\n:::\n\n\nSeveral useful methods haven been implemented for lazy elements. For example,\nyou can use the slicing operator to read the full data or a part of the data:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nadata.X[:]\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\narray([[1., 1., 1., 1.],\n       [1., 1., 1., 1.],\n       [1., 1., 1., 1.]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nadata.X[:2, :2]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\narray([[1., 1.],\n       [1., 1.]])\n```\n:::\n:::\n\n\nYou can also iterate over the chunks of the matrix using the `chunked` method:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nfor chunk, fr, to in adata.obsm.el('matrix').chunked(chunk_size=2):\n    print(\"from row {} to {}: {}\".format(fr, to - 1, chunk))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfrom row 0 to 1: [[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]\n [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]\nfrom row 2 to 2: [[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]\n```\n:::\n:::\n\n\nBy default AnnData will read from the disk each time you request the data.\nThis will incur a lot of IO overheads if you do this repetitively. \n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n%%time\nfor _ in range(1000):\n    adata.obsm['matrix']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCPU times: user 72.1 ms, sys: 324 µs, total: 72.5 ms\nWall time: 73.5 ms\n```\n:::\n:::\n\n\nOne solution to this is to turn on the cache for the element you want to repetitively read from.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n%%time\nadata.obsm.el('matrix').enable_cache()\nfor _ in range(1000):\n    adata.obsm['matrix']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCPU times: user 2.46 ms, sys: 0 ns, total: 2.46 ms\nWall time: 2.54 ms\n```\n:::\n:::\n\n\nThe data will be cached the first time you request it and the subsequent calls will make use of the cached data.\n\n### Subsetting the AnnData\n\nThe backed AnnData object does not have \"views\".\nInstead, you need to use the `AnnData.subset` method to create a new AnnData object.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nadata_subset = adata.subset([0, 1], [0, 1], out=\"subset.h5ad\")\nadata_subset\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nAnnData object with n_obs x n_vars = 2 x 2 backed at 'subset.h5ad'\n    obsm: 'matrix'\n    varm: 'another_matrix'\n```\n:::\n:::\n\n\nYou could also do this inplace without the `out` parameter:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nadata_subset.subset([0])\nadata_subset\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nAnnData object with n_obs x n_vars = 1 x 2 backed at 'subset.h5ad'\n    obsm: 'matrix'\n    varm: 'another_matrix'\n```\n:::\n:::\n\n\n### Convert to in-memory representation\n\nFinally, you can convert a backed AnnData to `anndata`'s in-memory AnnData object using:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nadata.to_memory()\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nAnnData object with n_obs × n_vars = 3 × 4\n    obsm: 'matrix'\n    varm: 'another_matrix'\n```\n:::\n:::\n\n\n## Combining multiple AnnData objects into a AnnDataSet object\n\nOftentimes you want to combine and deal with multiple h5ad files simultaniously.\nIn this section you will learn how to do this efficiently.\n\nFirst, let us create a bunch of AnnData objects.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\ndef create_anndata(index: int):\n    adata = snap.AnnData(\n        X=np.ones((4, 7))*index,\n        filename=str(index) + \".h5ad\",\n    )\n    adata.var_names = [str(i) for i in range(7)]\n    adata.obs_names = [str(i) for i in range(4)]\n    adata.obsm['matrix'] = np.random.rand(4,50)\n    return adata\nlist_of_anndata = [(str(i), create_anndata(i)) for i in range(10)]\n```\n:::\n\n\nWe can then use the `AnnDataSet` constructor to horizontally concatenate all AnnData objects.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ndataset = snap.AnnDataSet(\n    adatas=list_of_anndata,\n    filename=\"dataset.h5ads\",\n    add_key=\"id\",\n)\ndataset\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nAnnDataSet object with n_obs x n_vars = 40 x 7 backed at 'dataset.h5ads'\ncontains 10 AnnData objects with keys: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'\n    obs: 'id'\n    uns: 'AnnDataSet'\n```\n:::\n:::\n\n\nAnnDataSet is just a special form of AnnData objects.\nIt inherits most of the methods from AnnData.\nIt carries its own annotations, such as `obs`, `var`, `obsm`, *etc*.\nBesides, it grants you the access to component AnnData objects as well, as shown in the example below:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndataset.adatas.obsm['matrix']\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\narray([[0.12549264, 0.14607503, 0.57962118, ..., 0.44012067, 0.93976016,\n        0.02296648],\n       [0.63122475, 0.26952885, 0.97667297, ..., 0.38111847, 0.40170569,\n        0.46049124],\n       [0.45512582, 0.12006233, 0.98856133, ..., 0.72330538, 0.67213173,\n        0.64743067],\n       ...,\n       [0.43904307, 0.58470182, 0.88184627, ..., 0.67753381, 0.36187882,\n        0.51762232],\n       [0.20647608, 0.85508018, 0.22524564, ..., 0.79474184, 0.05559569,\n        0.50095913],\n       [0.93977617, 0.41847839, 0.7132005 , ..., 0.20903024, 0.72547171,\n        0.90385559]])\n```\n:::\n:::\n\n\n### Subsetting an AnnDataSet object\n\nAnnDataSet can be subsetted in a way similar to AnnData objects.\nBut there is one caveat: subsetting an AnnDataSet will not rearrange the rows across\ncomponent AnnData objects.\n\n### Converting AnnDataSet to AnnData\n\nAn in-memory AnnData can be made from AnnDataSet using:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ndataset.to_adata()\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nAnnData object with n_obs × n_vars = 40 × 7\n    obs: 'id'\n    uns: 'AnnDataSet'\n```\n:::\n:::\n\n\n",
    "supporting": [
      "anndata_files/figure-epub"
    ],
    "filters": [],
    "engineDependencies": {
      "jupyter": [
        {
          "jsWidgets": false,
          "jupyterWidgets": false,
          "htmlLibraries": []
        }
      ]
    }
  }
}